<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Kubernetes Integration · Otoroshi</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content='otoroshi-manual'/>
<link href="https://fonts.googleapis.com/css?family=Roboto:100normal,100italic,300normal,300italic,400normal,400italic,500normal,500italic,700normal,700italic,900normal,900italicc" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/groups.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="../css/page.css"/>

<!--
<link rel="shortcut icon" href="../images/favicon.ico" />
-->
</head>

<body>
<div class="off-canvas-wrapper">
<div class="off-canvas-wrapper-inner" data-off-canvas-wrapper>

<div class="off-canvas position-left" id="off-canvas-menu" data-off-canvas>
<nav class="off-canvas-nav">
<div class="nav-home">
<a href="../index.html" >
<span class="home-icon">⌂</span>Otoroshi
</a>
<div class="version-number">
1.4.23-dev
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="../about.html" class="page">About Otoroshi</a></li>
  <li><a href="../archi.html" class="page">Architecture</a></li>
  <li><a href="../features.html" class="page">Features</a></li>
  <li><a href="../quickstart.html" class="page">Try Otoroshi in 5 minutes</a></li>
  <li><a href="../getotoroshi/index.html" class="page">Get Otoroshi</a>
  <ul>
    <li><a href="../getotoroshi/fromsources.html" class="page">From sources</a></li>
    <li><a href="../getotoroshi/frombinaries.html" class="page">From binaries</a></li>
    <li><a href="../getotoroshi/fromdocker.html" class="page">From docker</a></li>
  </ul></li>
  <li><a href="../firstrun/index.html" class="page">First run</a>
  <ul>
    <li><a href="../firstrun/datastore.html" class="page">Choose your datastore</a></li>
    <li><a href="../firstrun/configfile.html" class="page">Config. with files</a></li>
    <li><a href="../firstrun/env.html" class="page">Config. with ENVs</a></li>
    <li><a href="../firstrun/initialstate.html" class="page">Import initial state</a></li>
    <li><a href="../firstrun/host.html" class="page">Setup your hosts</a></li>
    <li><a href="../firstrun/run.html" class="page">Run Otoroshi</a></li>
  </ul></li>
  <li><a href="../setup/index.html" class="page">Setup Otoroshi</a>
  <ul>
    <li><a href="../setup/admin.html" class="page">Manage admin users</a></li>
    <li><a href="../setup/dangerzone.html" class="page">Configure the Danger zone</a></li>
  </ul></li>
  <li><a href="../usage/index.html" class="page">Using Otoroshi</a>
  <ul>
    <li><a href="../usage/1-groups.html" class="page">Managing service groups</a></li>
    <li><a href="../usage/2-services.html" class="page">Managing services</a></li>
    <li><a href="../usage/3-apikeys.html" class="page">Managing API keys</a></li>
    <li><a href="../usage/4-monitor.html" class="page">Monitoring services</a></li>
    <li><a href="../usage/5-sessions.html" class="page">Managing sessions</a></li>
    <li><a href="../usage/6-audit.html" class="page">Auditing Otoroshi</a></li>
    <li><a href="../usage/7-metrics.html" class="page">Otoroshi global metrics</a></li>
    <li><a href="../usage/8-importsexports.html" class="page">Import and export</a></li>
    <li><a href="../usage/9-auth.html" class="page">Authentication</a></li>
  </ul></li>
  <li><a href="../integrations/index.html" class="page">Third party Integrations</a>
  <ul>
    <li><a href="../integrations/analytics.html" class="page">Analytics</a></li>
    <li><a href="../integrations/mailgun.html" class="page">Mailgun</a></li>
    <li><a href="../integrations/statsd.html" class="page">StatsD / Datadog</a></li>
    <li><a href="../integrations/clevercloud.html" class="page">Clever Cloud</a></li>
  </ul></li>
  <li><a href="../topics/index.html" class="page">Detailed topics</a>
  <ul>
    <li><a href="../topics/snow-monkey.html" class="page">Chaos engineering with the Snow Monkey</a></li>
    <li><a href="../topics/jwt-verifications.html" class="page">JWT Tokens verification</a></li>
    <li><a href="../topics/ssl.html" class="page">SSL/TLS termination with Otoroshi</a></li>
    <li><a href="../topics/mtls.html" class="page">Mutual TLS with Otoroshi</a></li>
    <li><a href="../topics/clustering.html" class="page">Otoroshi clustering</a></li>
    <li><a href="../topics/plugins.html" class="page">Otoroshi plugins</a></li>
    <li><a href="../topics/monitoring.html" class="page">Monitoring Otoroshi</a></li>
  </ul></li>
  <li><a href="../api.html" class="page">Admin REST API</a></li>
  <li><a href="../deploy/index.html" class="page">Deploy to production</a>
  <ul>
    <li><a href="../deploy/kubernetes.html" class="active page">Kubernetes Integration</a></li>
    <li><a href="../deploy/clevercloud.html" class="page">Clever Cloud</a></li>
    <li><a href="../deploy/aws-beanstalk.html" class="page">AWS - Elastic Beanstalk</a></li>
    <li><a href="../deploy/other.html" class="page">Others</a></li>
    <li><a href="../deploy/scaling.html" class="page">Scaling Otoroshi</a></li>
  </ul></li>
  <li><a href="../dev.html" class="page">Developing Otoroshi</a></li>
</ul>
</div>

</nav>
</div>

<div class="off-canvas-content" data-off-canvas-content>

<header class="site-header expanded row">
<div class="small-12 column">
<a href="#" class="off-canvas-toggle hide-for-medium" data-toggle="off-canvas-menu"><svg class="svg-icon svg-icon-menu" version="1.1" id="Menu" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve"> <path class="svg-icon-menu-path" fill="#53CDEC" d="M16.4,9H3.6C3.048,9,3,9.447,3,10c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,9.447,16.952,9,16.4,9z M16.4,13
H3.6C3.048,13,3,13.447,3,14c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,13.447,16.952,13,16.4,13z M3.6,7H16.4
C16.952,7,17,6.553,17,6c0-0.553-0.048-1-0.6-1H3.6C3.048,5,3,5.447,3,6C3,6.553,3.048,7,3.6,7z"/></svg>
</a>
<div class="title-wrapper">
<div class="title-logo"></div>
<div class="title"><a href="../index.html">Otoroshi</a></div>
</div>
<!--
<a href="https://www.example.com" class="logo show-for-medium">logo</a>
-->
</div>
</header>

<div class="expanded row">

<div class="medium-3 large-2 show-for-medium column">
<nav class="site-nav">
<div class="nav-home">
<a href="../index.html" >
<span class="home-icon">⌂</span>Otoroshi
</a>
<div class="version-number">
1.4.23-dev
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="../about.html" class="page">About Otoroshi</a></li>
  <li><a href="../archi.html" class="page">Architecture</a></li>
  <li><a href="../features.html" class="page">Features</a></li>
  <li><a href="../quickstart.html" class="page">Try Otoroshi in 5 minutes</a></li>
  <li><a href="../getotoroshi/index.html" class="page">Get Otoroshi</a>
  <ul>
    <li><a href="../getotoroshi/fromsources.html" class="page">From sources</a></li>
    <li><a href="../getotoroshi/frombinaries.html" class="page">From binaries</a></li>
    <li><a href="../getotoroshi/fromdocker.html" class="page">From docker</a></li>
  </ul></li>
  <li><a href="../firstrun/index.html" class="page">First run</a>
  <ul>
    <li><a href="../firstrun/datastore.html" class="page">Choose your datastore</a></li>
    <li><a href="../firstrun/configfile.html" class="page">Config. with files</a></li>
    <li><a href="../firstrun/env.html" class="page">Config. with ENVs</a></li>
    <li><a href="../firstrun/initialstate.html" class="page">Import initial state</a></li>
    <li><a href="../firstrun/host.html" class="page">Setup your hosts</a></li>
    <li><a href="../firstrun/run.html" class="page">Run Otoroshi</a></li>
  </ul></li>
  <li><a href="../setup/index.html" class="page">Setup Otoroshi</a>
  <ul>
    <li><a href="../setup/admin.html" class="page">Manage admin users</a></li>
    <li><a href="../setup/dangerzone.html" class="page">Configure the Danger zone</a></li>
  </ul></li>
  <li><a href="../usage/index.html" class="page">Using Otoroshi</a>
  <ul>
    <li><a href="../usage/1-groups.html" class="page">Managing service groups</a></li>
    <li><a href="../usage/2-services.html" class="page">Managing services</a></li>
    <li><a href="../usage/3-apikeys.html" class="page">Managing API keys</a></li>
    <li><a href="../usage/4-monitor.html" class="page">Monitoring services</a></li>
    <li><a href="../usage/5-sessions.html" class="page">Managing sessions</a></li>
    <li><a href="../usage/6-audit.html" class="page">Auditing Otoroshi</a></li>
    <li><a href="../usage/7-metrics.html" class="page">Otoroshi global metrics</a></li>
    <li><a href="../usage/8-importsexports.html" class="page">Import and export</a></li>
    <li><a href="../usage/9-auth.html" class="page">Authentication</a></li>
  </ul></li>
  <li><a href="../integrations/index.html" class="page">Third party Integrations</a>
  <ul>
    <li><a href="../integrations/analytics.html" class="page">Analytics</a></li>
    <li><a href="../integrations/mailgun.html" class="page">Mailgun</a></li>
    <li><a href="../integrations/statsd.html" class="page">StatsD / Datadog</a></li>
    <li><a href="../integrations/clevercloud.html" class="page">Clever Cloud</a></li>
  </ul></li>
  <li><a href="../topics/index.html" class="page">Detailed topics</a>
  <ul>
    <li><a href="../topics/snow-monkey.html" class="page">Chaos engineering with the Snow Monkey</a></li>
    <li><a href="../topics/jwt-verifications.html" class="page">JWT Tokens verification</a></li>
    <li><a href="../topics/ssl.html" class="page">SSL/TLS termination with Otoroshi</a></li>
    <li><a href="../topics/mtls.html" class="page">Mutual TLS with Otoroshi</a></li>
    <li><a href="../topics/clustering.html" class="page">Otoroshi clustering</a></li>
    <li><a href="../topics/plugins.html" class="page">Otoroshi plugins</a></li>
    <li><a href="../topics/monitoring.html" class="page">Monitoring Otoroshi</a></li>
  </ul></li>
  <li><a href="../api.html" class="page">Admin REST API</a></li>
  <li><a href="../deploy/index.html" class="page">Deploy to production</a>
  <ul>
    <li><a href="../deploy/kubernetes.html" class="active page">Kubernetes Integration</a></li>
    <li><a href="../deploy/clevercloud.html" class="page">Clever Cloud</a></li>
    <li><a href="../deploy/aws-beanstalk.html" class="page">AWS - Elastic Beanstalk</a></li>
    <li><a href="../deploy/other.html" class="page">Others</a></li>
    <li><a href="../deploy/scaling.html" class="page">Scaling Otoroshi</a></li>
  </ul></li>
  <li><a href="../dev.html" class="page">Developing Otoroshi</a></li>
</ul>
</div>

</nav>
</div>

<div class="small-12 medium-9 large-10 column">
<section class="site-content">

<div class="page-header row">
<div class="medium-12 show-for-medium column">
<div class="nav-breadcrumbs">
<ul>
  <li><a href="../index.html">Otoroshi</a></li>
  <li><a href="../deploy/index.html">Deploy to production</a></li>
  <li>Kubernetes Integration</li>
</ul>
</div>
</div>
</div>

<div class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#kubernetes-integration" name="kubernetes-integration" class="anchor"><span class="anchor-link"></span></a>Kubernetes Integration</h1>
<p>Starting at version 1.5.0, Otoroshi provides a native Kubernetes support. Multiple jobs (kubernetes controllers) are provided in order to</p>
<ul>
  <li>sync kubernetes secrets of type <code>kubernetes.io/tls</code> to otoroshi certificates</li>
  <li>act as a standard ingress controller (supporting <code>Ingress</code> objects)</li>
  <li>provide Custom Resource Definitions (CRDs) in order to manage Otoroshi entities from Kubernetes and act as some kind of ingress controller with its own resources</li>
</ul>
<h2><a href="#deploy-otoroshi-on-your-kubernetes-cluster" name="deploy-otoroshi-on-your-kubernetes-cluster" class="anchor"><span class="anchor-link"></span></a>Deploy otoroshi on your kubernetes cluster</h2>
<p>If you want to deploy otoroshi into your kubernetes cluster, you can download the deployment descriptors from <a href="https://github.com/MAIF/otoroshi/tree/master/kubernetes">https://github.com/MAIF/otoroshi/tree/master/kubernetes</a> and use kustomize to create your own overlay. The base descriptors are available at <a href="https://github.com/MAIF/otoroshi/tree/master/kubernetes/base">https://github.com/MAIF/otoroshi/tree/master/kubernetes/base</a></p>
<p>Then deploy it with <code>kubectl apply -k ./overlays/myoverlay</code>. </p>
<p>You can also create a <code>kustomization.yaml</code> file with a remote base</p>
<pre class="prettyprint"><code class="language-yaml">bases:
- github.com/MAIF/otoroshi/kubernetes/overlays/prod/?ref=v1.5.0
</code></pre>
<p>and apply it</p>
<p>An Helm chart will be available as soon as possible</p>
<h3><a href="#deploy-otoroshi-on-your-baremetal-kubernetes-cluster" name="deploy-otoroshi-on-your-baremetal-kubernetes-cluster" class="anchor"><span class="anchor-link"></span></a>Deploy otoroshi on your baremetal kubernetes cluster</h3>
<p>Baremetal cluster don&rsquo;t come with support for external loadbalancers. So you will have to provide this feature in order to route TCP traffic from outside into Otoroshi containers running inside kubernetes. You&rsquo;ll have to expose the following domain name through your own external load balancer (nginx, haproxy, otoroshi ;) ), and do the needed DNS setup accordingly</p>
<ul>
  <li><code>otoroshi.your.domain</code> going to kubernetes service <code>otoroshi-service</code> (or <code>otoroshi-leader-service</code> if in cluster mode)</li>
  <li><code>otoroshi-api.your.domain</code> going to kubernetes service <code>otoroshi-service</code> (or <code>otoroshi-leader-service</code> if in cluster mode)</li>
  <li><code>privateapps.your.domain</code> going to kubernetes service <code>otoroshi-service</code> (or <code>otoroshi-leader-service</code> if in cluster mode)</li>
  <li><code>anything.you.want</code> going to kubernetes service <code>otoroshi-service</code> (or <code>otoroshi-worker-service</code> if in cluster mode)</li>
</ul>
<p>to expose otoroshi to the outside world, you can use either</p>
<ul>
  <li><code>nodePort</code></li>
  <li><code>DaemonSet</code> deployement with <code>hostPort</code></li>
</ul>
<p>then just install <a href="https://www.nginx.com/">NGINX</a> or <a href="http://www.haproxy.org/">HAProxy</a> instances that will proxy your TCP calls (L4) to the kubernetes nodes from ports 80 and 443 to the ports chosen as <code>nodePort</code> or <code>hostPort</code>. Here are some example for configuring nginx or haproxy</p>
<dl>
  <dt>NGINX L4</dt>
  <dd>
  <pre class="prettyprint"><code class="language-conf">stream {

  upstream back_http_nodes {
    zone back_http_nodes 64k;
    server 192.168.1.40:8080 max_fails=1;
    server 192.168.1.41:8080 max_fails=1;
    server 192.168.1.42:8080 max_fails=1;
  }

  upstream back_https_nodes {
    zone back_https_nodes 64k;
    server 192.168.1.40:8443 max_fails=1;
    server 192.168.1.41:8443 max_fails=1;
    server 192.168.1.42:8443 max_fails=1;
  }

  server {
    listen     80;
    proxy_pass back_http_nodes;
    health_check;
  }

  server {
    listen     443;
    proxy_pass back_https_nodes;
    health_check;
  }
  
}
</code></pre></dd>
  <dt>HA Proxy L4</dt>
  <dd>
  <pre class="prettyprint"><code class="language-conf">frontend front_nodes_http
    bind *:80
    mode tcp
    default_backend back_http_nodes
    timeout client          1m

frontend front_nodes_https
    bind *:443
    mode tcp
    default_backend back_https_nodes
    timeout client          1m

backend back_http_nodes
    mode tcp
    balance roundrobin
    server node1 192.168.1.40:8080
    server node2 192.168.1.41:8080
    server node3 192.168.1.42:8080
    timeout connect        10s
    timeout server          1m

backend back_https_nodes
    mode tcp
    balance roundrobin
    server node1 192.168.1.40:8443
    server node2 192.168.1.41:8443
    server node3 192.168.1.42:8443
    timeout connect        10s
    timeout server          1m</code></pre></dd>
</dl>
<p>You can also use projects like <a href="https://metallb.universe.tf/">MetalLB</a> that provide <code>LoadBalancer</code> services to baremetal clusters</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>We don&rsquo;t recommand running Otoroshi behind an existing ingress controller (or something like that) as you will not be able to use features like TCP proxying, TLS, mTLS, etc. Also, this additional layer of reverse proxy will increase call latencies.</p></div>
<h2><a href="#use-otoroshi-as-an-ingress-controller" name="use-otoroshi-as-an-ingress-controller" class="anchor"><span class="anchor-link"></span></a>Use Otoroshi as an Ingress Controller</h2>
<p>If you want to use Otoroshi as an <a href="https://kubernetes.io/fr/docs/concepts/services-networking/ingress/">Ingress Controller</a>, just go to the danger zone, and in <code>Global scripts</code> add the job named <code>Kubernetes Ingress Controller</code>.</p>
<p>Then add the following configuration for the job (with your own tweak of course)</p>
<pre class="prettyprint"><code class="language-json">{
  &quot;KubernetesConfig&quot;: {
    &quot;enabled&quot;: true,
    &quot;endpoint&quot;: &quot;https://127.0.0.1:6443&quot;,
    &quot;token&quot;: &quot;eyJhbGciOiJSUzI....F463SrpOehQRaQ&quot;,
    &quot;namespaces&quot;: [
      &quot;*&quot;
    ]
  }
}
</code></pre>
<p>the configuration can have the following values </p>
<pre class="prettyprint"><code class="language-javascript">{
  &quot;KubernetesConfig&quot;: {
    &quot;endpoint&quot;: &quot;https://127.0.0.1:6443&quot;, // the endpoint to talk to the kubernetes api, optional
    &quot;token&quot;: &quot;xxxx&quot;, // the bearer token to talk to the kubernetes api, optional
    &quot;userPassword&quot;: &quot;user:password&quot;, // the user password tuple to talk to the kubernetes api, optional
    &quot;caCert&quot;: &quot;/etc/ca.cert&quot;, // the ca cert file path to talk to the kubernetes api, optional
    &quot;trust&quot;: false, // trust any cert to talk to the kubernetes api, optional
    &quot;namespaces&quot;: [&quot;*&quot;], // the watched namespaces
    &quot;labels&quot;: [&quot;label&quot;], // the watched namespaces
    &quot;ingressClass&quot;: &quot;otoroshi&quot;, // the watched kubernetes.io/ingress.class annotation, can be *
    &quot;defaultGroup&quot;: &quot;default&quot;, // the group to put services in otoroshi
    &quot;ingresses&quot;: true, // sync ingresses
    &quot;crds&quot;: false, // sync crds
    &quot;kubeLeader&quot;: false, // delegate leader election to kubernetes, to know where the sync job should run
    &quot;restartDependantDeployments&quot;: true, // when a secret/cert changes from otoroshi sync, restart dependant deployments
    &quot;templates&quot;: {
      &quot;service-group&quot;: {},
      &quot;service-descriptor&quot;: {},
      &quot;apikeys&quot;: {},
      &quot;global-config&quot;: {},
      &quot;jwt-verifier&quot;: {},
      &quot;tcp-service&quot;: {},
      &quot;certificate&quot;: {},
      &quot;auth-module&quot;: {},
      &quot;script&quot;: {},
    }
  }
}
</code></pre>
<p>If <code>endpoint</code> is not defined, Otoroshi will try to get it from <code>$KUBERNETES_SERVICE_HOST</code> and <code>$KUBERNETES_SERVICE_PORT</code>. If <code>token</code> is not defined, Otoroshi will try to get it from the file at <code>/var/run/secrets/kubernetes.io/serviceaccount/token</code>. If <code>caCert</code> is not defined, Otoroshi will try to get it from the file at <code>/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</code>. If <code>$KUBECONFIG</code> is defined, <code>endpoint</code>, <code>token</code> and <code>caCert</code> will be read from the current context of the file referenced by it.</p>
<p>Now you can deploy your first service ;)</p>
<h3><a href="#deploy-an-ingress-route" name="deploy-an-ingress-route" class="anchor"><span class="anchor-link"></span></a>Deploy an ingress route</h3>
<p>now let&rsquo;s say you want to deploy an http service and route to the outside world through otoroshi</p>
<pre class="prettyprint"><code class="language-yaml">---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: http-app-deployment
spec:
  selector:
    matchLabels:
      run: http-app-deployment
  replicas: 1
  template:
    metadata:
      labels:
        run: http-app-deployment
    spec:
      containers:
      - image: kennethreitz/httpbin
        imagePullPolicy: IfNotPresent
        name: otoroshi
        ports:
          - containerPort: 80
            name: &quot;http&quot;
---
apiVersion: v1
kind: Service
metadata:
  name: http-app-service
spec:
  ports:
    - port: 8080
      targetPort: http
      name: http
  selector:
    run: http-app-deployment
---
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: http-app-ingress
  annotations:
    kubernetes.io/ingress.class: otoroshi
spec:
  tls:
  - hosts:
    - httpapp.foo.bar
    secretName: http-app-cert
  rules:
  - host: httpapp.foo.bar
    http:
      paths:
      - path: /
        backend:
          serviceName: http-app-service
          servicePort: 8080
</code></pre>
<p>once deployed, otoroshi will sync with kubernetes and create the corresponding service to route your app. You will be able to access your app with</p>
<pre class="prettyprint"><code class="language-sh">curl -X GET https://httpapp.foo.bar/get
</code></pre>
<h3><a href="#use-multiple-ingress-controllers" name="use-multiple-ingress-controllers" class="anchor"><span class="anchor-link"></span></a>Use multiple ingress controllers</h3>
<p>It is of course possible to use multiple ingress controller at the same time (<a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/#using-multiple-ingress-controllers">https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/#using-multiple-ingress-controllers</a>) using the annotation <code>kubernetes.io/ingress.class</code>. By default, otoroshi reacts to the class <code>otoroshi</code>, but you can make it the default ingress controller with the following config</p>
<pre class="prettyprint"><code class="language-json">{
  &quot;KubernetesConfig&quot;: {
    ...
    &quot;ingressClass&quot;: &quot;*&quot;,
    ...
  }
}
</code></pre>
<h3><a href="#supported-annotations" name="supported-annotations" class="anchor"><span class="anchor-link"></span></a>Supported annotations</h3>
<p>if you need to customize the service descriptor behind an ingress rule, you can use some annotations. If you need better customisation, just go to the CRDs part. The following annotations are supported :</p>
<ul>
  <li><code>otoroshi.ingress.kubernetes.io/group</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/groupId</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/name</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/targetsLoadBalancing</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/stripPath</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/enabled</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/userFacing</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/privateApp</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/forceHttps</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/maintenanceMode</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/buildMode</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/strictlyPrivate</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/sendOtoroshiHeadersBack</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/readOnly</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/xForwardedHeaders</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/overrideHost</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/allowHttp10</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/logAnalyticsOnServer</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/useAkkaHttpClient</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/useNewWSClient</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/tcpUdpTunneling</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/detectApiKeySooner</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/letsEncrypt</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/publicPatterns</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/privatePatterns</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/additionalHeaders</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/additionalHeadersOut</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/missingOnlyHeadersIn</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/missingOnlyHeadersOut</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/removeHeadersIn</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/removeHeadersOut</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/headersVerification</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/matchingHeaders</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/ipFiltering.whitelist</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/ipFiltering.blacklist</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/api.exposeApi</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/api.openApiDescriptorUrl</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/healthCheck.enabled</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/healthCheck.url</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/jwtVerifier.ids</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/jwtVerifier.enabled</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/jwtVerifier.excludedPatterns</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/authConfigRef</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/redirection.enabled</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/redirection.code</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/redirection.to</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/clientValidatorRef</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/transformerRefs</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/transformerConfig</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/accessValidator.enabled</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/accessValidator.excludedPatterns</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/accessValidator.refs</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/accessValidator.config</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/preRouting.enabled</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/preRouting.excludedPatterns</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/preRouting.refs</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/preRouting.config</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/issueCert</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/issueCertCA</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/gzip.enabled</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/gzip.excludedPatterns</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/gzip.whiteList</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/gzip.blackList</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/gzip.bufferSize</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/gzip.chunkedThreshold</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/gzip.compressionLevel</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/cors.enabled</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/cors.allowOrigin</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/cors.exposeHeaders</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/cors.allowHeaders</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/cors.allowMethods</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/cors.excludedPatterns</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/cors.maxAge</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/cors.allowCredentials</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/clientConfig.useCircuitBreaker</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/clientConfig.retries</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/clientConfig.maxErrors</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/clientConfig.retryInitialDelay</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/clientConfig.backoffFactor</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/clientConfig.connectionTimeout</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/clientConfig.idleTimeout</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/clientConfig.callAndStreamTimeout</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/clientConfig.callTimeout</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/clientConfig.globalTimeout</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/clientConfig.sampleInterval</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/enforceSecureCommunication</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/sendInfoToken</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/sendStateChallenge</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/secComHeaders.claimRequestName</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/secComHeaders.stateRequestName</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/secComHeaders.stateResponseName</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/secComTtl</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/secComVersion</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/secComInfoTokenVersion</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/secComExcludedPatterns</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/secComSettings.size</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/secComSettings.secret</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/secComSettings.base64</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/secComUseSameAlgo</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/secComAlgoChallengeOtoToBack.size</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/secComAlgoChallengeOtoToBack.secret</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/secComAlgoChallengeOtoToBack.base64</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/secComAlgoChallengeBackToOto.size</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/secComAlgoChallengeBackToOto.secret</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/secComAlgoChallengeBackToOto.base64</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/secComAlgoInfoToken.size</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/secComAlgoInfoToken.secret</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/secComAlgoInfoToken.base64</code></li>
  <li><code>otoroshi.ingress.kubernetes.io/securityExcludedPatterns</code></li>
</ul>
<p>for more informations about it, just go to <a href="https://maif.github.io/otoroshi/swagger-ui/index.html">https://maif.github.io/otoroshi/swagger-ui/index.html</a></p>
<p>with the previous example, the ingress does not define any apikey, so the route is public. If you want to enable apikeys on it, you can deploy the following descriptor</p>
<pre class="prettyprint"><code class="language-yaml">apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: http-app-ingress
  annotations:
    kubernetes.io/ingress.class: otoroshi
    otoroshi.ingress.kubernetes.io/group: http-app-group
    otoroshi.ingress.kubernetes.io/forceHttps: &#39;true&#39;
    otoroshi.ingress.kubernetes.io/sendOtoroshiHeadersBack: &#39;true&#39;
    otoroshi.ingress.kubernetes.io/overrideHost: &#39;true&#39;
    otoroshi.ingress.kubernetes.io/allowHttp10: &#39;false&#39;
    otoroshi.ingress.kubernetes.io/publicPatterns: &#39;&#39;
spec:
  tls:
  - hosts:
    - httpapp.foo.bar
    secretName: http-app-cert
  rules:
  - host: httpapp.foo.bar
    http:
      paths:
      - path: /
        backend:
          serviceName: http-app-service
          servicePort: 8080
</code></pre>
<p>now you can use an existing apikey in the <code>http-app-group</code> to access your app</p>
<pre class="prettyprint"><code class="language-sh">curl -X GET https://httpapp.foo.bar/get -u existing-apikey-1:secret-1
</code></pre>
<h2><a href="#use-otoroshi-crds-for-a-better-full-integration" name="use-otoroshi-crds-for-a-better-full-integration" class="anchor"><span class="anchor-link"></span></a>Use Otoroshi CRDs for a better/full integration</h2>
<p>Otoroshi provides some Custom Resource Definitions for kubernetes in order to manager Otoroshi related entities in kubernetes</p>
<ul>
  <li><code>service-groups</code></li>
  <li><code>service-descriptors</code></li>
  <li><code>apikeys</code></li>
  <li><code>certificates</code></li>
  <li><code>global-configs</code></li>
  <li><code>jwt-verifiers</code></li>
  <li><code>auth-modules</code></li>
  <li><code>scripts</code></li>
  <li><code>tcp-services</code></li>
  <li><code>admins</code></li>
</ul>
<p>using CRDs, you will be able to deploy and manager those entities from kubectl or the kubernetes api like</p>
<pre class="prettyprint"><code class="language-sh">sudo kubectl get apikeys --all-namespaces
sudo kubectl get service-descriptors --all-namespaces
curl -X GET \
  -H &#39;Authorization: Bearer eyJhbGciOiJSUzI....F463SrpOehQRaQ&#39; \
  -H &#39;Accept: application/json&#39; -k \
  https://127.0.0.1:6443/apis/proxy.otoroshi.io/v1alpha1/apikeys | jq
</code></pre><div class="callout warning "><div class="callout-title">Warning</div>
<p>when using Otoroshi CRDs, Kubernetes becomes the single source of truth for the synced entities. It means that any value in the descriptors deployed will overrides the one in Otoroshi datastore each time it&rsquo;s synced. So be careful if you use the Otoroshi UI or the API, some changes in configuration may be overriden by CRDs sync job.</p></div>
<p>To configure it, just go to the danger zone, and in <code>Global scripts</code> add the job named <code>Kubernetes Otoroshi CRDs Controller</code>. Then add the following configuration for the job (with your own tweak of course)</p>
<pre class="prettyprint"><code class="language-json">{
  &quot;KubernetesConfig&quot;: {
    &quot;enabled&quot;: true,
    &quot;crds&quot;: true,
    &quot;endpoint&quot;: &quot;https://127.0.0.1:6443&quot;,
    &quot;token&quot;: &quot;eyJhbGciOiJSUzI....F463SrpOehQRaQ&quot;,
    &quot;namespaces&quot;: [
      &quot;*&quot;
    ]
  }
}
</code></pre>
<p>then you can deploy the previous example with better configuration level, and using mtls, apikeys, etc</p>
<p>Let say the app looks like :</p>
<pre class="prettyprint"><code class="language-js">const fs = require(&#39;fs&#39;); 
const https = require(&#39;https&#39;); 

// here we read the apikey to access http-app-2 from files mounted from secrets
const clientId = fs.readFileSync(&#39;/var/run/secrets/kubernetes.io/apikeys/clientId&#39;).toString(&#39;utf8&#39;)
const clientSecret = fs.readFileSync(&#39;/var/run/secrets/kubernetes.io/apikeys/clientSecret&#39;).toString(&#39;utf8&#39;)

// here we read the certificate for the app
const crt = fs.readFileSync(&#39;/var/run/secrets/kubernetes.io/certs/tls.crt&#39;)
  .toString(&#39;utf8&#39;)
  .split(&#39;-----BEGIN CERTIFICATE-----\n&#39;)
  .filter(s =&gt; s.trim() !== &#39;&#39;);
const cert = &#39;-----BEGIN CERTIFICATE-----\n&#39; + crt.shift()
const ca = crt.join(&#39;-----BEGIN CERTIFICATE-----\n&#39;)

function callApi2() {
  return new Promise((success, failure) =&gt; {
    const options = { 
      hostname: &#39;httpapp2.foo.bar&#39;, 
      port: 433, 
      path: &#39;/&#39;, 
      method: &#39;GET&#39;,
      headers: {
        &#39;Accept&#39;: &#39;application/json&#39;,
        &#39;Otoroshi-Client-Id&#39;: clientId,
        &#39;Otoroshi-Client-Secret&#39;: clientSecret,
      }
    }; 
    let data = &#39;&#39;;
    const req = https.request(options, (res) =&gt; { 
      res.on(&#39;data&#39;, (d) =&gt; { 
        data = data + d.toString(&#39;utf8&#39;);
      }); 
      res.on(&#39;end&#39;, () =&gt; { 
        success({ body: JSON.parse(data), res });
      }); 
      res.on(&#39;error&#39;, (e) =&gt; { 
        failure(e);
      }); 
    }); 
    req.end();
  })
}

const options = { 
  key: fs.readFileSync(&#39;/var/run/secrets/kubernetes.io/certs/tls.key&#39;), 
  cert: cert, 
  ca: ca, 
  // we want mtls behavior
  requestCert: true, 
  rejectUnauthorized: true
}; 
https.createServer(options, (req, res) =&gt; { 
  res.writeHead(200, {&#39;Content-Type&#39;: &#39;application/json&#39;});
  callApi2().then(resp =&gt; {
    res.write(JSON.stringify{ (&quot;message&quot;: `Hello to ${req.socket.getPeerCertificate().subject.CN}`, api2: resp.body })); 
  });
}).listen(433);
</code></pre>
<p>then, the descriptors will be :</p>
<pre class="prettyprint"><code class="language-yaml">---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: http-app-deployment
spec:
  selector:
    matchLabels:
      run: http-app-deployment
  replicas: 1
  template:
    metadata:
      labels:
        run: http-app-deployment
    spec:
      containers:
      - image: foo/http-app
        imagePullPolicy: IfNotPresent
        name: otoroshi
        ports:
          - containerPort: 443
            name: &quot;https&quot;
        volumeMounts:
        - name: apikey-volume
          # here you will be able to read apikey from files 
          # - /var/run/secrets/kubernetes.io/apikeys/clientId
          # - /var/run/secrets/kubernetes.io/apikeys/clientSecret
          mountPath: &quot;/var/run/secrets/kubernetes.io/apikeys&quot;
          readOnly: true
        volumeMounts:
        - name: cert-volume
          # here you will be able to read app cert from files 
          # - /var/run/secrets/kubernetes.io/certs/tls.crt
          # - /var/run/secrets/kubernetes.io/certs/tls.key
          mountPath: &quot;/var/run/secrets/kubernetes.io/certs&quot;
          readOnly: true
      volumes:
      - name: apikey-volume
        secret:
          # here we reference the secret name from apikey http-app-2-apikey-1
          secretName: secret-2
      - name: cert-volume
        secret:
          # here we reference the secret name from cert http-app-certificate-backend
          secretName: http-app-certificate-backend-secret
---
apiVersion: v1
kind: Service
metadata:
  name: http-app-service
spec:
  ports:
    - port: 8443
      targetPort: httpss
      name: https
  selector:
    run: http-app-deployment
---
apiVersion: proxy.otoroshi.io/v1alpha1
kind: ServiceGroup
metadata:
  name: http-app-group
spec:
  description: a group to hold services about the http-app
---
apiVersion: proxy.otoroshi.io/v1alpha1
kind: ApiKey
metadata:
  name: http-app-apikey-1
# this apikey can be used to access the app
spec:
  # a secret name secret-1 will be created by otoroshi and can be used by containers
  exportSecret: true 
  secretName: secret-1
  group: http-app-group
---
apiVersion: proxy.otoroshi.io/v1alpha1
kind: ApiKey
metadata:
  name: http-app-2-apikey-1
# this apikey can be used to access another app in a different group
spec:
  # a secret name secret-1 will be created by otoroshi and can be used by containers
  exportSecret: true 
  secretName: secret-2
  group: http-app-2-group
---
apiVersion: proxy.otoroshi.io/v1alpha1
kind: Certificate
metadata:
  name: http-app-certificate-frontend
spec:
  description: certificate for the http-app on otorshi frontend
  autoRenew: true
  csr:
    issuer: CN=Otoroshi Root
    hosts: 
    - httpapp.foo.bar
    key:
      algo: rsa
      size: 2048
    subject: UID=httpapp-front, O=OtoroshiApps
    client: false
    ca: false
    duration: 31536000000
    signatureAlg: SHA256WithRSAEncryption
    digestAlg: SHA-256
---
apiVersion: proxy.otoroshi.io/v1alpha1
kind: Certificate
metadata:
  name: http-app-certificate-backend
spec:
  description: certificate for the http-app deployed on pods
  autoRenew: true
  # a secret name http-app-certificate-backend-secret will be created by otoroshi and can be used by containers
  exportSecret: true 
  secretName: http-app-certificate-backend-secret
  csr:
    issuer: CN=Otoroshi Root
    hosts: 
    - http-app-service
    key:
      algo: rsa
      size: 2048
    subject: UID=httpapp-back, O=OtoroshiApps
    client: false
    ca: false
    duration: 31536000000
    signatureAlg: SHA256WithRSAEncryption
    digestAlg: SHA-256
---
apiVersion: proxy.otoroshi.io/v1alpha1
kind: Certificate
metadata:
  name: http-app-certificate-client
spec:
  description: certificate for the http-app
  autoRenew: true
  csr:
    issuer: CN=Otoroshi Root
    key:
      algo: rsa
      size: 2048
    subject: UID=httpapp-client, O=OtoroshiApps
    client: false
    ca: false
    duration: 31536000000
    signatureAlg: SHA256WithRSAEncryption
    digestAlg: SHA-256
---
apiVersion: proxy.otoroshi.io/v1alpha1
kind: ServiceDescriptor
metadata:
  name: http-app-service-descriptor
spec:
  description: the service descriptor for the http app
  group: http-app-group
  forceHttps: true
  hosts:
  - httpapp.foo.bar
  matchingRoot: /
  targets:
  - url: https://http-app-service:8443
    # alternatively, you can use serviceName and servicePort to use pods ip addresses
    # serviceName: http-app-service
    # servicePort: https
    mtlsConfig:
      # use mtls to contact the backend
      mtls: true
      certs: 
        # reference the DN for the client cert
        - UID=httpapp-client, O=OtoroshiApps
      trustedCerts: 
        # reference the DN for the CA cert
        - CN=Otoroshi Root
  sendOtoroshiHeadersBack: true
  xForwardedHeaders: true
  overrideHost: true
  allowHttp10: false
  publicPatterns:
    - /health
  additionalHeaders:
    x-foo: bar
# here you can specify everything supported by otoroshi like jwt-verifiers, auth config, etc ... for more informations about it, just go to https://maif.github.io/otoroshi/swagger-ui/index.html
</code></pre>
<p>now with this descriptor deployed, you can access your app with a command like </p>
<pre class="prettyprint"><code class="language-sh">CLIENT_ID=`kubectl get secret secret-1 -o jsonpath=&quot;{.data.clientId}&quot; | base64 --decode`
CLIENT_SECRET=`kubectl get secret secret-1 -o jsonpath=&quot;{.data.clientSecret}&quot; | base64 --decode`
curl -X GET https://httpapp.foo.bar/get -u &quot;$CLIENT_ID:$CLIENT_SECRET&quot;
</code></pre>
<h2><a href="#expose-otoroshi-to-outside-world" name="expose-otoroshi-to-outside-world" class="anchor"><span class="anchor-link"></span></a>Expose Otoroshi to outside world</h2>
<p>If you deploy Otoroshi on a kubernetes cluster, the Otoroshi service is deployed as a loadbalancer. You&rsquo;ll need to declare in your DNS settings any name that can be routed by otoroshi going to the loadbalancer endpoint of your kubernetes distribution.</p>
<h2><a href="#access-a-service-from-inside-the-k8s-cluster" name="access-a-service-from-inside-the-k8s-cluster" class="anchor"><span class="anchor-link"></span></a>Access a service from inside the k8s cluster</h2>
<p>You can access any service referenced in otoroshi, through otoroshin from inside the kubernetes cluster by using the internal otoroshi service (if you use a template based on <a href="https://github.com/MAIF/otoroshi/tree/master/kubernetes/base">https://github.com/MAIF/otoroshi/tree/master/kubernetes/base</a>) name and the host header with the service domain like :</p>
<pre class="prettyprint"><code class="language-sh">CLIENT_ID=&quot;xxx&quot;
CLIENT_SECRET=&quot;xxx&quot;
curl -X GET -H &#39;Host: httpapp.foo.bar&#39; https://otoroshi-internal-service:8443/get -u &quot;$CLIENT_ID:$CLIENT_SECRET&quot;
</code></pre>
<h2><a href="#daikoku-integration" name="daikoku-integration" class="anchor"><span class="anchor-link"></span></a>Daikoku integration</h2>
<p>It is possible to easily integrate daikoku generated apikeys without any human interaction with the actual apikey secret. To do that, create a plan in Daikoku and setup the integration mode to <code>Automatic</code></p><div class="centered-img">
<img src="../img/kubernetes-daikoku-integration-enabled.png" /></div>
<p>then when a user subscribe for an apikey, he will only see an integration token</p><div class="centered-img">
<img src="../img/kubernetes-daikoku-integration-token.png" /></div>
<p>then just create an ApiKey manifest with this token and your good to go</p>
<pre class="prettyprint"><code class="language-yaml">apiVersion: proxy.otoroshi.io/v1alpha1
kind: ApiKey
metadata:
  name: http-app-2-apikey-3
spec:
  exportSecret: true 
  secretName: secret-3
  daikokuToken: RShQrvINByiuieiaCBwIZfGFgdPu7tIJEN5gdV8N8YeH4RI9ErPYJzkuFyAkZ2xy
</code></pre>
<div class="nav-next">
<p><strong>Next:</strong> <a href="../deploy/clevercloud.html">Clever Cloud</a></p>
</div>
</div>
<div class="large-3 show-for-large column" data-sticky-container>
<nav class="sidebar sticky" data-sticky data-anchor="docs" data-sticky-on="large">
<div class="page-nav">
<div class="nav-title">On this page:</div>
<div class="nav-toc">
<ul>
  <li><a href="../deploy/kubernetes.html#kubernetes-integration" class="header">Kubernetes Integration</a>
  <ul>
    <li><a href="../deploy/kubernetes.html#deploy-otoroshi-on-your-kubernetes-cluster" class="header">Deploy otoroshi on your kubernetes cluster</a></li>
    <li><a href="../deploy/kubernetes.html#use-otoroshi-as-an-ingress-controller" class="header">Use Otoroshi as an Ingress Controller</a></li>
    <li><a href="../deploy/kubernetes.html#use-otoroshi-crds-for-a-better-full-integration" class="header">Use Otoroshi CRDs for a better/full integration</a></li>
    <li><a href="../deploy/kubernetes.html#expose-otoroshi-to-outside-world" class="header">Expose Otoroshi to outside world</a></li>
    <li><a href="../deploy/kubernetes.html#access-a-service-from-inside-the-k8s-cluster" class="header">Access a service from inside the k8s cluster</a></li>
    <li><a href="../deploy/kubernetes.html#daikoku-integration" class="header">Daikoku integration</a></li>
  </ul></li>
</ul>
</div>
</div>
</nav>
</div>
</div>

</section>
</div>

</div>

<footer class="site-footer">

<section class="site-footer-nav">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 medium-4 large-3 text-center column">
<div class="nav-links">
<ul>
<!-- <li><a href="https://www.example.com/products/">Products</a> -->
</ul>
</div>
</div>

</div>
</div>
</div>
</section>

<section class="site-footer-base">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 text-center large-9 column">

<!--
<div class="copyright">
<span class="text">&copy; 2020</span>
<a href="https://www.example.com" class="logo">logo</a>
</div>
-->
</div>

</div>
</div>
</div>
</section>
</footer>

</div>
</div>
</div>
</body>

<script type="text/javascript" src="../lib/foundation/dist/foundation.min.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/magellan.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/elasticlunr/0.9.5/elasticlunr.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-112498312-1"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());

gtag('config', 'UA-112498312-1');
</script>
</html>




